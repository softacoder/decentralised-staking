{"ast":null,"code":"var _jsxFileName = \"/Users/jansofta/Documents/GitHub/decentralised-staking/challenge-1-decentralized-staking/packages/react-app/src/components/BytesStringInput.jsx\",\n  _s = $RefreshSig$();\nimport { Input } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst {\n  utils,\n  constants\n} = require(\"ethers\");\n\n/*\n  ~ What it does? ~\n\n  Displays input field with options to convert between STRING and BYTES32\n\n  ~ How can I use? ~\n\n  <BytesStringInput\n    autofocus\n    value={\"scaffold-eth\"}\n    placeholder=\"Enter value...\"\n    onChange={value => {\n      setValue(value);\n    }}\n  />\n\n  ~ Features ~\n\n  - Provide value={value} to specify initial string\n  - Provide placeholder=\"Enter value...\" value for the input\n  - Control input change by onChange={value => { setValue(value);}}\n\n*/\n\nexport default function BytesStringInput(props) {\n  _s();\n  const [mode, setMode] = useState(\"STRING\");\n  const [display, setDisplay] = useState();\n  const [value, setValue] = useState(constants.HashZero);\n\n  // current value is the value in bytes32\n  const currentValue = typeof props.value !== \"undefined\" ? props.value : value;\n  const option = title => {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        cursor: \"pointer\"\n      },\n      onClick: () => {\n        if (mode === \"STRING\") {\n          setMode(\"BYTES32\");\n          if (!utils.isHexString(currentValue)) {\n            /* in case user enters invalid bytes32 number,\n                 it considers it as string and converts to bytes32 */\n            const changedValue = utils.formatBytes32String(currentValue);\n            setDisplay(changedValue);\n          } else {\n            setDisplay(currentValue);\n          }\n        } else {\n          setMode(\"STRING\");\n          if (currentValue && utils.isHexString(currentValue)) {\n            setDisplay(utils.parseBytes32String(currentValue));\n          } else {\n            setDisplay(currentValue);\n          }\n        }\n      },\n      children: title\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 40,\n      columnNumber: 7\n    }, this);\n  };\n  let addonAfter;\n  if (mode === \"STRING\") {\n    addonAfter = option(\"STRING ðŸ”€\");\n  } else {\n    addonAfter = option(\"BYTES32 ðŸ”€\");\n  }\n  useEffect(() => {\n    if (!currentValue) {\n      setDisplay(\"\");\n    }\n  }, [currentValue]);\n  return /*#__PURE__*/_jsxDEV(Input, {\n    placeholder: props.placeholder ? props.placeholder : \"Enter value in \" + mode,\n    autoFocus: props.autoFocus,\n    value: display,\n    addonAfter: addonAfter,\n    onChange: async e => {\n      const newValue = e.target.value;\n      if (mode === \"STRING\") {\n        // const ethValue = parseFloat(newValue) / props.price;\n        // setValue(ethValue);\n        if (typeof props.onChange === \"function\") {\n          props.onChange(utils.formatBytes32String(newValue));\n        }\n        setValue(utils.formatBytes32String(newValue));\n        setDisplay(newValue);\n      } else {\n        if (typeof props.onChange === \"function\") {\n          props.onChange(newValue);\n        }\n        setValue(newValue);\n        setDisplay(newValue);\n      }\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 82,\n    columnNumber: 5\n  }, this);\n}\n_s(BytesStringInput, \"Q0b/1t/0+Dyow4AhGaAVa+Dc/Gc=\");\n_c = BytesStringInput;\nvar _c;\n$RefreshReg$(_c, \"BytesStringInput\");","map":{"version":3,"names":["Input","React","useEffect","useState","jsxDEV","_jsxDEV","utils","constants","require","BytesStringInput","props","_s","mode","setMode","display","setDisplay","value","setValue","HashZero","currentValue","option","title","style","cursor","onClick","isHexString","changedValue","formatBytes32String","parseBytes32String","children","fileName","_jsxFileName","lineNumber","columnNumber","addonAfter","placeholder","autoFocus","onChange","e","newValue","target","_c","$RefreshReg$"],"sources":["/Users/jansofta/Documents/GitHub/decentralised-staking/challenge-1-decentralized-staking/packages/react-app/src/components/BytesStringInput.jsx"],"sourcesContent":["import { Input } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\n\nconst { utils, constants } = require(\"ethers\");\n\n/*\n  ~ What it does? ~\n\n  Displays input field with options to convert between STRING and BYTES32\n\n  ~ How can I use? ~\n\n  <BytesStringInput\n    autofocus\n    value={\"scaffold-eth\"}\n    placeholder=\"Enter value...\"\n    onChange={value => {\n      setValue(value);\n    }}\n  />\n\n  ~ Features ~\n\n  - Provide value={value} to specify initial string\n  - Provide placeholder=\"Enter value...\" value for the input\n  - Control input change by onChange={value => { setValue(value);}}\n\n*/\n\nexport default function BytesStringInput(props) {\n  const [mode, setMode] = useState(\"STRING\");\n  const [display, setDisplay] = useState();\n  const [value, setValue] = useState(constants.HashZero);\n\n  // current value is the value in bytes32\n  const currentValue = typeof props.value !== \"undefined\" ? props.value : value;\n\n  const option = title => {\n    return (\n      <div\n        style={{ cursor: \"pointer\" }}\n        onClick={() => {\n          if (mode === \"STRING\") {\n            setMode(\"BYTES32\");\n            if (!utils.isHexString(currentValue)) {\n              /* in case user enters invalid bytes32 number,\n                   it considers it as string and converts to bytes32 */\n              const changedValue = utils.formatBytes32String(currentValue);\n              setDisplay(changedValue);\n            } else {\n              setDisplay(currentValue);\n            }\n          } else {\n            setMode(\"STRING\");\n            if (currentValue && utils.isHexString(currentValue)) {\n              setDisplay(utils.parseBytes32String(currentValue));\n            } else {\n              setDisplay(currentValue);\n            }\n          }\n        }}\n      >\n        {title}\n      </div>\n    );\n  };\n\n  let addonAfter;\n  if (mode === \"STRING\") {\n    addonAfter = option(\"STRING ðŸ”€\");\n  } else {\n    addonAfter = option(\"BYTES32 ðŸ”€\");\n  }\n\n  useEffect(() => {\n    if (!currentValue) {\n      setDisplay(\"\");\n    }\n  }, [currentValue]);\n\n  return (\n    <Input\n      placeholder={props.placeholder ? props.placeholder : \"Enter value in \" + mode}\n      autoFocus={props.autoFocus}\n      value={display}\n      addonAfter={addonAfter}\n      onChange={async e => {\n        const newValue = e.target.value;\n        if (mode === \"STRING\") {\n          // const ethValue = parseFloat(newValue) / props.price;\n          // setValue(ethValue);\n          if (typeof props.onChange === \"function\") {\n            props.onChange(utils.formatBytes32String(newValue));\n          }\n          setValue(utils.formatBytes32String(newValue));\n          setDisplay(newValue);\n        } else {\n          if (typeof props.onChange === \"function\") {\n            props.onChange(newValue);\n          }\n          setValue(newValue);\n          setDisplay(newValue);\n        }\n      }}\n    />\n  );\n}\n"],"mappings":";;AAAA,SAASA,KAAK,QAAQ,MAAM;AAC5B,OAAOC,KAAK,IAAIC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEnD,MAAM;EAAEC,KAAK;EAAEC;AAAU,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAASC,gBAAgBA,CAACC,KAAK,EAAE;EAAAC,EAAA;EAC9C,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGV,QAAQ,CAAC,QAAQ,CAAC;EAC1C,MAAM,CAACW,OAAO,EAAEC,UAAU,CAAC,GAAGZ,QAAQ,CAAC,CAAC;EACxC,MAAM,CAACa,KAAK,EAAEC,QAAQ,CAAC,GAAGd,QAAQ,CAACI,SAAS,CAACW,QAAQ,CAAC;;EAEtD;EACA,MAAMC,YAAY,GAAG,OAAOT,KAAK,CAACM,KAAK,KAAK,WAAW,GAAGN,KAAK,CAACM,KAAK,GAAGA,KAAK;EAE7E,MAAMI,MAAM,GAAGC,KAAK,IAAI;IACtB,oBACEhB,OAAA;MACEiB,KAAK,EAAE;QAAEC,MAAM,EAAE;MAAU,CAAE;MAC7BC,OAAO,EAAEA,CAAA,KAAM;QACb,IAAIZ,IAAI,KAAK,QAAQ,EAAE;UACrBC,OAAO,CAAC,SAAS,CAAC;UAClB,IAAI,CAACP,KAAK,CAACmB,WAAW,CAACN,YAAY,CAAC,EAAE;YACpC;AACd;YACc,MAAMO,YAAY,GAAGpB,KAAK,CAACqB,mBAAmB,CAACR,YAAY,CAAC;YAC5DJ,UAAU,CAACW,YAAY,CAAC;UAC1B,CAAC,MAAM;YACLX,UAAU,CAACI,YAAY,CAAC;UAC1B;QACF,CAAC,MAAM;UACLN,OAAO,CAAC,QAAQ,CAAC;UACjB,IAAIM,YAAY,IAAIb,KAAK,CAACmB,WAAW,CAACN,YAAY,CAAC,EAAE;YACnDJ,UAAU,CAACT,KAAK,CAACsB,kBAAkB,CAACT,YAAY,CAAC,CAAC;UACpD,CAAC,MAAM;YACLJ,UAAU,CAACI,YAAY,CAAC;UAC1B;QACF;MACF,CAAE;MAAAU,QAAA,EAEDR;IAAK;MAAAS,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACH,CAAC;EAEV,CAAC;EAED,IAAIC,UAAU;EACd,IAAItB,IAAI,KAAK,QAAQ,EAAE;IACrBsB,UAAU,GAAGd,MAAM,CAAC,WAAW,CAAC;EAClC,CAAC,MAAM;IACLc,UAAU,GAAGd,MAAM,CAAC,YAAY,CAAC;EACnC;EAEAlB,SAAS,CAAC,MAAM;IACd,IAAI,CAACiB,YAAY,EAAE;MACjBJ,UAAU,CAAC,EAAE,CAAC;IAChB;EACF,CAAC,EAAE,CAACI,YAAY,CAAC,CAAC;EAElB,oBACEd,OAAA,CAACL,KAAK;IACJmC,WAAW,EAAEzB,KAAK,CAACyB,WAAW,GAAGzB,KAAK,CAACyB,WAAW,GAAG,iBAAiB,GAAGvB,IAAK;IAC9EwB,SAAS,EAAE1B,KAAK,CAAC0B,SAAU;IAC3BpB,KAAK,EAAEF,OAAQ;IACfoB,UAAU,EAAEA,UAAW;IACvBG,QAAQ,EAAE,MAAMC,CAAC,IAAI;MACnB,MAAMC,QAAQ,GAAGD,CAAC,CAACE,MAAM,CAACxB,KAAK;MAC/B,IAAIJ,IAAI,KAAK,QAAQ,EAAE;QACrB;QACA;QACA,IAAI,OAAOF,KAAK,CAAC2B,QAAQ,KAAK,UAAU,EAAE;UACxC3B,KAAK,CAAC2B,QAAQ,CAAC/B,KAAK,CAACqB,mBAAmB,CAACY,QAAQ,CAAC,CAAC;QACrD;QACAtB,QAAQ,CAACX,KAAK,CAACqB,mBAAmB,CAACY,QAAQ,CAAC,CAAC;QAC7CxB,UAAU,CAACwB,QAAQ,CAAC;MACtB,CAAC,MAAM;QACL,IAAI,OAAO7B,KAAK,CAAC2B,QAAQ,KAAK,UAAU,EAAE;UACxC3B,KAAK,CAAC2B,QAAQ,CAACE,QAAQ,CAAC;QAC1B;QACAtB,QAAQ,CAACsB,QAAQ,CAAC;QAClBxB,UAAU,CAACwB,QAAQ,CAAC;MACtB;IACF;EAAE;IAAAT,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACH,CAAC;AAEN;AAACtB,EAAA,CA7EuBF,gBAAgB;AAAAgC,EAAA,GAAhBhC,gBAAgB;AAAA,IAAAgC,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}